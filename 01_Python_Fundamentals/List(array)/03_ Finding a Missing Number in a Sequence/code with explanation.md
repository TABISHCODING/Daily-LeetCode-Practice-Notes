

# ðŸ”¢ Python Program: Finding a Missing Number in a Sequence

This guide explains three different methods to find the first missing number in a sequence of integers. We will cover a robust general-purpose solution and two other common algorithmic approaches.

-----

## **Method 1: Hash Set + Dynamic Range (The Best & Most Robust Method)**

This is the best and most robust general-purpose solution. It finds the range dynamically before checking for missing numbers.

### **1. The Code**

```python
def findMissingNumber(self, nums: list[int]) -> int | None:
    """
    METHOD: HASH SET + DYNAMIC RANGE (Active)
    This is the best and most robust general-purpose solution. It finds
    the range dynamically before checking for missing numbers.

    Time Complexity: O(n)
    Space Complexity: O(n)
    """
    # A list needs at least two numbers to define a potential gap.
    if len(nums) < 2:
        return None

    # Step 1: Create a set for fast O(1) average time lookups.
    seen_numbers = set(nums)

    # Step 2: Dynamically find the sequence's start and end points.
    # This is the key that makes the solution "general".
    start = min(nums)
    end = max(nums)

    # Step 3: Loop through the *actual* range, not a fixed [0, n] range.
    for number in range(start, end + 1):
        # Step 4: Return the first number from the complete range
        # that is not in our set of seen numbers.
        if number not in seen_numbers:
            return number

    # If the loop finishes, it means there were no gaps.
    return None
```

### **2. The Step-by-Step Approach**

Let's break down the logic of this method.

  * **How the Loop Knows Where to Start (from `min(nums)`, not 0)**
    The loop starts from whatever `min(nums)` finds. It is **not** hardcoded to start at 0.
    Let's use our example: `nums = [10, 13, 11, 14]`

    1.  `start = min(nums)` finds the smallest number, which is **10**.
    2.  `end = max(nums)` finds the largest number, which is **14**.
    3.  The loop becomes `for number in range(10, 14 + 1):`.
        So, the loop will run for the numbers `10, 11, 12, 13, 14`. It starts from **10** because that's the minimum value in your list.

  * **How It Checks for 12**
    This is the brilliant part. The `range()` function **generates every integer** between the start and end, creating a "perfect" sequence, and the `for` loop checks if each of those generated numbers exists in your original list.

    Here's the step-by-step flow:

    1.  The `range(10, 15)` starts generating numbers.
    2.  The `for` loop gets the **first** number from the generator, which is **10**. It checks `if 10 not in seen_numbers`. It is, so the loop continues.
    3.  The loop gets the **second** number, **11**. It checks `if 11 not in seen_numbers`. It is, so the loop continues.
    4.  The loop gets the **third** number, **12**. This number was generated by `range` because it's a necessary part of the complete sequence from 10 to 14.
    5.  The code then checks `if 12 not in seen_numbers`. The set is `{10, 11, 13, 14}`. The number **12 is not in the set**, so the condition is **True**, and the function returns the value **12**.

-----

## **Reference Method 1: Sorting + Gap Check**

This is the second-best general solution. It's very space-efficient but slower than the hash set method for large lists.

### **1. The Code**

```python
def findMissingNumber_sorting(self, nums: list[int]) -> int | None:
    # Time Complexity: O(n log n)
    # Space Complexity: O(1)

    if len(nums) < 2:
        return None

    # Step 1: Sort the list. This brings all consecutive numbers next to each other.
    # e.g., [10, 13, 11, 14] becomes [10, 11, 13, 14]
    nums.sort()

    # Step 2: Loop through the sorted list.
    for i in range(len(nums) - 1):
        # Step 3: Instead of checking against the index 'i', we check for a "gap".
        # A gap exists if the next number isn't one greater than the current number.
        if nums[i+1] != nums[i] + 1:
            # The missing number is the one that should have been after nums[i].
            return nums[i] + 1
    
    return None
```

### **2. The Step-by-Step Approach**

This explains the logic of the sorting-based version.

  * **Step 1: Sort the List**
    The code first sorts the list, so `[10, 13, 11, 14]` becomes `[10, 11, 13, 14]`.

  * **Step 2: Loop and Check for Gaps**
    The code then starts a `for` loop that uses an index `i`. The loop runs up to the *second-to-last* element, so we can safely compare each element with the one that comes after it. Hereâ€™s how the loop executes with the sorted list `[10, 11, 13, 14]`:

      * **Loop 1: `i = 0`**

          * The current element `nums[i]` (which is `nums[0]`) is **10**.
          * The next element `nums[i+1]` (which is `nums[1]`) is **11**.
          * The code checks the condition: `if nums[i+1] != nums[i] + 1`.
          * This becomes: `if 11 != 10 + 1`.
          * The condition is **false** because `11` is equal to `11`. There is no gap here, so the loop continues.

      * **Loop 2: `i = 1`**

          * The current element `nums[i]` (which is `nums[1]`) is **11**.
          * The next element `nums[i+1]` (which is `nums[2]`) is **13**.
          * The code checks the condition: `if nums[i+1] != nums[i] + 1`.
          * This becomes: `if 13 != 11 + 1`.
          * The condition is **true** because `13` is not equal to `12`. **A gap has been found\!**

  * **Step 3: Return the Missing Number**
    Because the `if` condition was true, the code inside it executes: `return nums[i] + 1`.

      * It takes the value of the current element `nums[i]`, which is **11**.
      * It adds 1 to it: `11 + 1 = 12`.
      * The function immediately **returns the value 12** and stops running.

-----

## **Reference Method 2: Arithmetic Sum**

This is a very efficient solution but is **less flexible**. It only works correctly if **exactly one number** is missing from a consecutive sequence.

### **1. The Code**

```python
def findMissingNumber_math(self, nums: list[int]) -> int | None:
    # This is a very efficient solution but can be less intuitive.
    # It only works correctly if exactly one number is missing.
    # Time Complexity: O(n)
    # Space Complexity: O(1)

    if len(nums) < 2:
        return None

    # Step 1: Find the boundaries of the expected sequence.
    start = min(nums)
    end = max(nums)

    # Step 2: Calculate the sum the sequence SHOULD HAVE using the
    # formula for an arithmetic sum: Sum = (n/2) * (first + last).
    num_terms = end - start + 1
    expected_sum = num_terms * (start + end) // 2

    # Step 3: Calculate the sum the list ACTUALLY has.
    actual_sum = sum(nums)

    # Step 4: The difference is the missing number.
    missing_number = expected_sum - actual_sum

    # If the difference is 0, no numbers were missing.
    return missing_number if missing_number != 0 else None
```
