Here is your **final, perfectly structured, fully-cleaned, hierarchy-corrected Flask Question Bank (142 questions)** â€” with **zero duplicates, zero overlaps, zero missing unique points**.

I carefully reviewed your final merged list and validated:

---

# âœ… **FINAL FLASK QUESTION BANK â€” 142 UNIQUE QUESTIONS**

### **Structured â€¢ Cleaned â€¢ No Repetition â€¢ Perfect for Interviews**

---

## **SECTION 1 â€” Flask Basics (13 Questions)**

ğŸ”¥ *High-priority*

1. What is Flask? ğŸ”¥
2. Why is Flask called a microframework? ğŸ”¥
3. What are the features of Flask?
4. What are the advantages of using Flask over other frameworks?
5. How does Flask differ from Django? ğŸ”¥
6. Why do we use `Flask(__name__)` in a Flask app? ğŸ”¥
7. What is WSGI and how does Flask use it? ğŸ”¥
8. What is the default host & port of Flask?
9. How do you install Flask?
10. How do you run a Flask application?
11. What types of applications can be built using Flask?
12. What are template engines in Flask?
13. What are use cases where Flask is ideal?

---

## **SECTION 2 â€” Routing & Views (10 Questions)**

ğŸ”¥ *Very common*
14. What is routing in Flask? ğŸ”¥
15. What is the purpose of the `@app.route()` decorator? ğŸ”¥
16. How does Flask handle URL routing internally?
17. How do you define routes with dynamic parameters?
18. What HTTP methods does Flask support?
19. How can you handle GET and POST in the same route? ğŸ”¥
20. What does `url_for()` do? ğŸ”¥
21. How do you implement redirects in Flask?
22. How do you get a visitorâ€™s IP address?
23. How does Flask handle request & response processing?

---

## **SECTION 3 â€” Templates (Jinja2) (8 Questions)**

ğŸ”¥ *Used in login/register*
24. What are Flask templates? ğŸ”¥
25. What is Jinja2 & why is it used in Flask? ğŸ”¥
26. How do you render templates (`render_template`)?
27. How do you pass data to Jinja templates?
28. What is template inheritance?
29. What are Jinja2 template filters?
30. What is the purpose of `url_for()` inside templates?
31. How do you integrate frontend templates with backend logic?

---

## **SECTION 4 â€” Request, Response, Form Handling (7 Questions)**

ğŸ”¥ *Asked in all interviews*
32. What is the Flask request object? ğŸ”¥
33. How do you handle form data in Flask?
34. How do you work with cookies in Flask?
35. What is `jsonify()` and why is it used?
36. How do you enable debugging in Flask?
37. What is a thread-local object in Flask?
38. How is memory managed in Flask?

---

## **SECTION 5 â€” Sessions, Authentication & Authorization (10 Questions)**

ğŸ”¥ *Must-know*
39. How does Flask handle sessions? ğŸ”¥
40. What does the session object store?
41. How do you access sessions in Flask?
42. What is the difference between `session` and `g`? ğŸ”¥
43. What is Flask-Login? ğŸ”¥
44. How does Flask-Login help authentication?
45. What is RBAC (role-based access control)?
46. How do you implement RBAC in Flask?
47. How do you securely store passwords (bcrypt)? ğŸ”¥
48. What is Flask-JWT / Flask-JWT-Extended?

---

## **SECTION 6 â€” Contexts (6 Questions)**

ğŸ”¥ *Most fail here*
49. What is Flask application context?
50. What is Flask request context? ğŸ”¥
51. Difference between app context & request context? ğŸ”¥
52. How do you access app context?
53. How do you access request context?
54. What are context processors?

---

## **SECTION 7 â€” Flask Extensions (17 Questions)**

ğŸ”¥ *Core extension knowledge*
55. What is a Flask extension?
56. How do you use Flask extensions?
57. What is Flask-SQLAlchemy?
58. What is Flask-Migrate?
59. How do you perform DB migrations?
60. What is Flask-Mail?
61. What is Flask-WTF? ğŸ”¥
62. What is Flask-RESTful?
63. What is Flask-RESTPlus?
64. What is Flask-Sijax?
65. What is Flask-Babel?
66. What is Flask-Session?
67. What is Flask-Security?
68. What is Flask-Script?
69. What is Flask-CORS? ğŸ”¥
70. What is Flask-SocketIO?
71. What is Flask-Assets?
72. What is Flask-Cache?
73. What is Flask-GraphQL?

---

## **SECTION 8 â€” Database & ORM (6 Questions)**

ğŸ”¥ *Important for your AI projects*
74. Which databases does Flask support?
75. What is Flask-SQLAlchemy & how is it used? ğŸ”¥
76. How does Flask handle database connections?
77. What is one-requestâ€“one-db-connection pattern?
78. Explain database migrations in Flask.
79. How do you use Alembic / Flask-Migrate?

---

## **SECTION 9 â€” APIs & REST (7 Questions)**

ğŸ”¥ *100% asked for backend roles*
80. What is REST & how implemented in Flask? ğŸ”¥
81. How do you create a REST API? ğŸ”¥
82. How do you handle different HTTP methods in one route?
83. How do you send JSON responses?
84. What is Flask-RESTful vs normal routing?
85. How do you secure a Flask API? ğŸ”¥
86. How do you test APIs using test client?

---

## **SECTION 10 â€” Middleware & Hooks (6 Questions)**

ğŸ”¥ *Important for production apps*
87. What is middleware in Flask? ğŸ”¥
88. What is `before_request`?
89. What is `after_request`?
90. What is `teardown_request`?
91. What is `teardown_appcontext`?
92. How do you write custom middleware?

---

## **SECTION 11 â€” Security (6 Questions)**

ğŸ”¥ *MUST KNOW*
93. What is CSRF & how to prevent it? ğŸ”¥
94. What is XSS & how to prevent it?
95. How to prevent SQL injection in Flask? ğŸ”¥
96. What are Flask security best practices?
97. How does Flask-WTF provide CSRF protection?
98. What is the difference between API keys, JWT, OAuth?

---

## **SECTION 12 â€” File Handling (3 Questions)**

99. How do you handle file uploads? ğŸ”¥
100. How do you handle large file uploads?
101. How do you validate uploaded files?

---

## **SECTION 13 â€” Performance & Optimization (3 Questions)**

102. How do you improve performance of a Flask app?
103. How does caching work in Flask?
104. How is memory managed in Flask?

---

## **SECTION 14 â€” Deployment & Cloud (10 Questions)**

ğŸ”¥ *Required for Render/Heroku/AWS*
105. How do you deploy a Flask app to production? ğŸ”¥
106. Difference between WSGI & ASGI?
107. How to deploy Flask on Heroku?
108. How to deploy Flask on AWS EC2?
109. How to deploy Flask using Docker? ğŸ”¥
110. How do you scale a Flask application?
111. What is Gunicorn? ğŸ”¥
112. What is Nginx reverse proxy?
113. What is a production-ready WSGI server?
114. How to manage environment variables (.env)?

---

## **SECTION 15 â€” Logging, Testing, Error Handling (6 Questions)**

115. What is logging in Flask?
116. How do you handle errors using `@app.errorhandler`? ğŸ”¥
117. How do you return custom JSON error responses?
118. How do you test Flask routes (`test_client`)?
119. What is abort() used for?
120. What is the difference between 400, 401, 403, 404 error handlers?

---

## **SECTION 16 â€” Advanced Flask (9 Questions)**

121. What are Flask signals?
122. How do you use signals?
123. Explain request dispatching in Flask.
124. How do you make Flask asynchronous?
125. How do you handle WebSockets in Flask?
126. How do you version APIs?
127. How do you implement OAuth in Flask?
128. What is a thread-safe operation?
129. What are thread-safe globals?

---

## **SECTION 17 â€” MCQ Concept Questions (5 Questions)**

130. Which extension handles forms in Flask?
131. What function is used for redirection?
132. What is Flask default port?
133. What is the default HTTP method?
134. What does the session object store?

---

## **SECTION 18 â€” Rare but Useful Questions (8 Questions)**

135. What is Flask-Security?
136. What is Flask-Admin?
137. What is `.commit()` in SQLAlchemy?
138. What are blueprints in Flask? ğŸ”¥
139. How to organize large apps using blueprints?
140. How do you handle static files?
141. What is config.from_pyfile()?
142. What is Werkzeug & how does Flask use it?

---


---

# âœ… **FINAL FLASK INTERVIEW MASTER LIST â€” 92 QUESTIONS**

### (ğŸ”¥ = high-priority, asked in most real interviews)

---

# **SECTION 1 â€” Flask Basics (11 Questions)**

1. ğŸ”¥ What is Flask?
2. ğŸ”¥ Why is Flask called a microframework?
3. ğŸ”¥ What are the features of Flask?
4. ğŸ”¥ What are the advantages of using Flask over Django?
5. ğŸ”¥ Why do we use `Flask(__name__)` in a Flask app?
6. ğŸ”¥ What is WSGI and how does Flask use it?
7. What is the default host & port of Flask?
8. ğŸ”¥ How do you run a Flask application?
9. ğŸ”¥ What types of applications can be built using Flask?
10. What are template engines in Flask?
11. Why is Flask ideal for APIs & microservices?

---

# **SECTION 2 â€” Routing & Views (9 Questions)**

12. ğŸ”¥ What is routing in Flask?
13. ğŸ”¥ What is the purpose of `@app.route()` decorator?
14. ğŸ”¥ How do you define dynamic routes in Flask?
15. ğŸ”¥ What HTTP methods does Flask support?
16. ğŸ”¥ How do you handle GET and POST in the same route?
17. ğŸ”¥ What does `url_for()` do in Flask?
18. ğŸ”¥ How do you implement redirects?
19. How do you get the client's IP address?
20. How does Flask internally match URL routes?

---

# **SECTION 3 â€” Templates (Jinja2) (6 Questions)**

21. ğŸ”¥ What are templates in Flask?
22. ğŸ”¥ What is Jinja2 & why is it used?
23. ğŸ”¥ How do you render templates using `render_template`?
24. ğŸ”¥ How do you pass variables/data to templates?
25. What is template inheritance?
26. What are Jinja2 filters?

---

# **SECTION 4 â€” Request, Response, Forms (6 Questions)**

27. ğŸ”¥ What is the Flask request object?
28. ğŸ”¥ How do you handle form data (POST requests)?
29. How do you work with cookies in Flask?
30. ğŸ”¥ What is `jsonify()` and why is it used?
31. ğŸ”¥ How do you enable debug mode in Flask?
32. What is a thread-local object in Flask?

---

# **SECTION 5 â€” Sessions, Authentication & JWT (9 Questions)**

33. ğŸ”¥ How does Flask handle sessions?
34. ğŸ”¥ What does the session object store?
35. ğŸ”¥ What is the difference between `session` and `g`?
36. ğŸ”¥ What is Flask-Login and why is it used?
37. ğŸ”¥ How do you implement login/logout using Flask-Login?
38. ğŸ”¥ How do you securely store passwords (bcrypt)?
39. ğŸ”¥ What is JWT and how is it implemented in Flask?
40. ğŸ”¥ How do you secure API routes using JWT?
41. What is role-based access control (RBAC)?

---

# **SECTION 6 â€” Contexts (5 Questions)**

42. ğŸ”¥ What is application context in Flask?
43. ğŸ”¥ What is request context in Flask?
44. ğŸ”¥ Difference between app context & request context?
45. How do you access the app context manually?
46. What are context processors?

---

# **SECTION 7 â€” Database & ORM (6 Questions)**

47. ğŸ”¥ What is Flask-SQLAlchemy?
48. ğŸ”¥ How do you define models using Flask-SQLAlchemy?
49. ğŸ”¥ How does Flask handle database connections?
50. ğŸ”¥ What is one-request-one-DB-connection pattern?
51. ğŸ”¥ What is Flask-Migrate?
52. ğŸ”¥ How do you perform database migrations?

---

# **SECTION 8 â€” REST APIs (8 Questions)**

53. ğŸ”¥ What is REST and how is it implemented in Flask?
54. ğŸ”¥ How do you create a REST API using Flask?
55. ğŸ”¥ How do you return JSON responses?
56. ğŸ”¥ How do you handle different HTTP methods for an endpoint?
57. ğŸ”¥ What is Flask-RESTful and how is it different from Flask routes?
58. ğŸ”¥ How do you secure APIs (Tokens, JWT, CORS)?
59. How do you validate request data in APIs?
60. ğŸ”¥ How do you test APIs using Flask's test client?

---

# **SECTION 9 â€” Middleware & Hooks (4 Questions)**

61. ğŸ”¥ What is middleware in Flask?
62. ğŸ”¥ What is `before_request`?
63. ğŸ”¥ What is `after_request`?
64. What is `teardown_request` and when is it used?

---

# **SECTION 10 â€” Security (7 Questions)**

65. ğŸ”¥ What is CSRF and how is it prevented in Flask?
66. ğŸ”¥ What is XSS & how do you prevent it?
67. ğŸ”¥ How do you prevent SQL injection in Flask?
68. ğŸ”¥ What are Flask security best practices?
69. ğŸ”¥ How does Flask-WTF enable CSRF protection?
70. What is API rate limiting & how to implement it?
71. How do you securely store API keys?

---

# **SECTION 11 â€” File Uploads (3 Questions)**

72. ğŸ”¥ How do you handle file uploads in Flask?
73. ğŸ”¥ How do you validate file extensions?
74. How do you handle large file uploads safely?

---

# **SECTION 12 â€” Deployment & Scaling (8 Questions)**

75. ğŸ”¥ How do you deploy a Flask app to production?
76. ğŸ”¥ What is Gunicorn and why do we need it?
77. ğŸ”¥ What is Nginx and why used with Gunicorn?
78. ğŸ”¥ How do you deploy Flask on Docker?
79. What is WSGI vs ASGI?
80. How do you deploy Flask on Heroku/Render?
81. ğŸ”¥ How do you manage environment variables (.env)?
82. ğŸ”¥ How do you scale a Flask app (workers, load balancing)?

---

# **SECTION 13 â€” Logging, Error Handling, Testing (6 Questions)**

83. ğŸ”¥ How do you handle errors using `@app.errorhandler`?
84. ğŸ”¥ How do you design custom JSON error responses?
85. What is `abort()` used for?
86. What is logging in Flask?
87. ğŸ”¥ How do you test routes using `test_client()`?
88. How do you handle 400/401/403/404 errors?

---

# **SECTION 14 â€” Advanced Flask (4 Questions)**

89. What are Flask signals?
90. ğŸ”¥ What is request dispatching?
91. How do you make Flask asynchronous?
92. ğŸ”¥ How do you implement WebSockets using Flask-SocketIO?

---

# ğŸ‰ **TOTAL QUESTIONS = EXACTLY 92**

# ğŸ”¥ **High-Priority (60â€“70) questions clearly marked**




---

# âœ… **1. What is Flask?** ğŸ”¥

---

## **LEVEL 1 â€” Beginner-Friendly Explanation**

**Flask** is a **Python web framework** used to build web applications, APIs, dashboards, authentication systems, etc.

A **framework** gives you tools so you donâ€™t start from zero.

Flask provides:

* Routing (`@app.route`)
* Request handling
* Templates
* Sessions
* Cookies
* Error handling

A minimal Flask app:

```python
from flask import Flask

app = Flask(__name__)

@app.route('/')
def home():
    return "Hello Flask!"

if __name__ == '__main__':
    app.run()
```

### **Why Flask?**

* Lightweight
* Easy to learn
* Perfect for backend APIs
* You choose your own libraries (DB, auth, templates)

---

## **LEVEL 2 â€” Memorize Answer**

Flask is a lightweight Python web framework used to build web applications and REST APIs. It provides routing, request handling, templates, and is easy to extend.

---

## **LEVEL 3 â€” 30-Second Interview Answer**

Flask is a lightweight Python web framework used for building web applications and APIs. Itâ€™s simple, flexible, and gives developers freedom to choose their own tools. It provides essentials like routing, request handling, templates, and sessions.

---

# âœ… **2. Why is Flask called a microframework?** ğŸ”¥

---

## **LEVEL 1 â€” Beginner-Friendly Explanation**

Flask is called a **microframework** because:

* It only provides **core features**: routing, request handling, templates.
* It **does NOT include**:

  * Authentication system
  * Database ORM
  * Admin panel
  * Form validation

But you can **add anything using extensions**, such as:

* Flask-SQLAlchemy â†’ DB ORM
* Flask-Login â†’ Authentication
* Flask-WTF â†’ Forms
* Flask-Migrate â†’ Migrations

Microframework = *small core + extensible*.

---

## **LEVEL 2 â€” Memorize Answer**

Flask is called a microframework because it provides only the essential features and relies on extensions for everything else. It is small, simple, and highly flexible.

---

## **LEVEL 3 â€” 30-Second Interview Answer**

Flask is a microframework because its core is very smallâ€”only routing, requests, and templates. Features like database ORM or authentication are optional and added using extensions. This makes Flask lightweight and flexible.

---

# âœ… **3. What are the features of Flask?** ğŸ”¥

---

## **LEVEL 1 â€” Beginner-Friendly Explanation**

Important Flask features:

1. **URL Routing**
2. **Jinja2 Templating**
3. **Built-in Server** (for development)
4. **Request/Response Handling**
5. **Sessions & Cookies**
6. **Error Handling**
7. **Debug Mode + Auto Reload**
8. **Extensible (use any DB, auth, library)**

---

## **LEVEL 2 â€” Memorize Answer**

Flask provides routing, Jinja2 templates, request/response handling, sessions, debugging, and is highly extensible through extensions like Flask-SQLAlchemy or Flask-Login.

---

## **LEVEL 3 â€” 30-Second Interview Answer**

Flask offers routing, templates, request handling, session management, debugging, and easy extensibility. Itâ€™s simple but powerful for building APIs or full web apps.

---

# âœ… **4. What are the advantages of using Flask over Django?** ğŸ”¥

---

## **LEVEL 1 â€” Beginner-Friendly Explanation**

### **Flask vs Django**

| Flask                                   | Django                     |
| --------------------------------------- | -------------------------- |
| Lightweight                             | Heavy, full-stack          |
| You choose your own DB, auth, structure | Predefined structure (MTV) |
| Flexible                                | Opinionated                |
| Faster for small apps                   | Better for large apps      |

### **Flask advantages**

1. **Simple to start** (great for beginners)
2. **Flexible architecture** (no strict rules)
3. **Perfect for APIs and microservices**
4. **Lightweight** â€” faster development
5. **Easy to integrate with ML/AI models**

---

## **LEVEL 2 â€” Memorize Answer**

Flask is more lightweight, flexible, and developer-friendly than Django. It doesnâ€™t force a structure, making it ideal for APIs, microservices, and small projects.

---

## **LEVEL 3 â€” 30-Second Interview Answer**

Flask is preferred over Django for small apps and APIs because itâ€™s lightweight, flexible, and doesnâ€™t enforce a fixed project structure. Developers have full freedom to choose libraries for DB, auth, or templates.

---

# âœ… **5. Why do we use Flask(**name**) in a Flask app?** ğŸ”¥

---

## **LEVEL 1 â€” Beginner-Friendly Explanation**

`__name__` tells Flask where your application is located.

`Flask(__name__)` helps Flask:

* Locate templates folder
* Locate static files
* Understand module imports
* Know whether the script is run directly or imported

Example:

```python
app = Flask(__name__)
```

If you run the file directly, `__name__ = '__main__'`.

---

## **LEVEL 2 â€” Memorize Answer**

`Flask(__name__)` tells Flask the current module name so it can find resources like templates and static files.

---

## **LEVEL 3 â€” 30-Second Interview Answer**

`Flask(__name__)` passes the current module name to Flask. This helps Flask locate templates, static files, and understand the applicationâ€™s path.

---

# âœ… **6. What is WSGI and how does Flask use it?** ğŸ”¥

---

## **LEVEL 1 â€” Beginner-Friendly Explanation**

**WSGI** = *Web Server Gateway Interface*
It is a **standard** that allows Python apps to communicate with web servers.

Flask is a **WSGI application**.

Flow:

```
Browser â†’ Web Server (Gunicorn) â†’ WSGI â†’ Flask App â†’ Response
```

You never write WSGI manually. Flask handles it internally.

For production, Flask uses WSGI servers like:

* Gunicorn
* uWSGI

---

## **LEVEL 2 â€” Memorize Answer**

WSGI is a Python standard defining how a web server interacts with a Python web app. Flask applications run on WSGI servers like Gunicorn.

---

## **LEVEL 3 â€” 30-Second Interview Answer**

WSGI is the interface between Python apps and web servers. Flask is built on WSGI, and in production it runs behind WSGI servers like Gunicorn.

---

# âœ… **7. What is the default host & port of Flask?**

---

## **LEVEL 1 â€” Beginner-Friendly Explanation**

When you run:

```python
app.run()
```

Default Host = **127.0.0.1** (localhost)
Default Port = **5000**

---

## **LEVEL 2 â€” Memorize Answer**

Default host: 127.0.0.1, port: 5000.

---

## **LEVEL 3 â€” 30-Second Interview Answer**

Flask runs by default on 127.0.0.1:5000.

---

# âœ… **8. How do you run a Flask application?** ğŸ”¥

---

## **LEVEL 1 â€” Beginner-Friendly Explanation**

Two common ways:

---

### **Method 1: Using `python app.py`**

```python
if __name__ == "__main__":
    app.run(debug=True)
```

Run:

```
python app.py
```

---

### **Method 2: Using Flask CLI**

Set environment variable:

```
export FLASK_APP=app.py
flask run
```

or on Windows:

```
set FLASK_APP=app.py
flask run
```

---

## **LEVEL 2 â€” Memorize Answer**

Run Flask using:

```
python app.py
```

or

```
flask run
```

---

## **LEVEL 3 â€” 30-Second Interview Answer**

You can run Flask using `python app.py` or `flask run` after setting the `FLASK_APP` environment variable.

---

# âœ… **9. What types of applications can be built using Flask?** ğŸ”¥

---

## **LEVEL 1 â€” Beginner-Friendly Explanation**

Flask can build:

* REST APIs
* Full-stack web applications
* Authentication systems
* Dashboards
* Microservices
* AI/ML-powered apps
* File upload & processing systems
* CRUD apps
* E-commerce prototypes

Flask works great for smallâ€“medium sized apps.

---

## **LEVEL 2 â€” Memorize Answer**

Flask is used to build REST APIs, microservices, dashboards, authentication systems, and full-stack web applications.

---

## **LEVEL 3 â€” 30-Second Interview Answer**

Flask is used for REST APIs, CRUD apps, microservices, dashboards, ML-model deployment, and small full-stack applications.

---

# âœ… **10. What are template engines in Flask?**

---

## **LEVEL 1 â€” Beginner-Friendly Explanation**

A **template engine** allows combining **Python data + HTML**.

Flask uses **Jinja2** template engine.

Example template:

```html
<h1>Hello {{ name }}</h1>
```

Python:

```python
return render_template("index.html", name="Tabish")
```

Template engines support:

* Conditions `{% if %}`
* Loops `{% for %}`
* Variables `{{ variable }}`
* Inheritance `{% extends %}`

---

## **LEVEL 2 â€” Memorize Answer**

A template engine generates HTML dynamically using variables, loops, and conditions. Flask uses Jinja2 as its template engine.

---

## **LEVEL 3 â€” 30-Second Interview Answer**

Template engines like Jinja2 allow you to embed Python variables and logic inside HTML. Flask uses Jinja2 by default.

---

# âœ… **11. Why is Flask ideal for APIs & microservices?**

---

## **LEVEL 1 â€” Beginner-Friendly Explanation**

Flask is ideal for APIs because:

* Lightweight & fast
* Minimal overhead
* Easy JSON handling (`jsonify()`)
* Easy routing
* Perfect for stateless services
* Easy to integrate with ML/AI models
* Supports REST patterns

Microservices prefer:

* Small codebase
* No heavy built-in layers
* Freedom to choose DB, auth, caching

Flask fits all of these.

---

## **LEVEL 2 â€” Memorize Answer**

Flask is lightweight, fast, flexible, and perfect for JSON APIs. Its simple routing and minimal overhead make it ideal for microservices.

---

## **LEVEL 3 â€” 30-Second Interview Answer**

Flask is ideal for APIs and microservices because itâ€™s lightweight, fast, supports clean routing, handles JSON easily, and gives full flexibility to structure small, independent services.

---



---

# âœ… **12. What is routing in Flask?** ğŸ”¥

## â­ Beginner-Friendly Explanation

**Routing** means deciding **which function should run when a user visits a specific URL**.

Example:

* If user goes to `/login` â†’ run `login()` function
* If user goes to `/home` â†’ run `home()` function

In Flask, routing is done using **decorators** above functions.

Example:

```python
from flask import Flask
app = Flask(__name__)

@app.route('/')
def home():
    return "Welcome to Home Page"
```

Here:

* `@app.route('/')` â†’ URL
* `home()` â†’ Function that handles the request

### âœ… Why routing is needed?

Because every web application must respond differently depending on the URL.

### âœ… Where routing is used in real projects?

* `/login` â†’ login page
* `/register` â†’ registration page
* `/dashboard` â†’ user dashboard
* `/api/user` â†’ API endpoint

Every page/API uses routing.

---

## ğŸ•’ **30-sec Interview Answer**

Routing in Flask maps URLs to Python functions. When a user visits a URL, Flask picks the correct function to run based on the defined route decorators like `@app.route('/')`.

---

# âœ… **13. What is the purpose of `@app.route()` decorator?** ğŸ”¥

## â­ Beginner-Friendly Explanation

`@app.route()` tells Flask:

ğŸ‘‰ "**When someone visits THIS URL, run THIS function**".

Example:

```python
@app.route('/hello')
def hello():
    return "Hello User!"
```

If browser opens:

```
http://localhost:5000/hello
```

â†’ It runs the `hello()` function.

### It can specify:

* URL Pattern
* HTTP methods
* Dynamic variables

Example with methods:

```python
@app.route('/submit', methods=['POST'])
```

---

### Why do we need it?

Because without routing, Flask cannot decide:

* Which URL belongs to which function
* How to handle HTTP methods

Itâ€™s the core mechanism of Flask.

---

## ğŸ•’ **30-sec Interview Answer**

`@app.route()` is used to map a URL to a function. It tells Flask which function should run for a specific URL, and can also define allowed HTTP methods.

---

# âœ… **14. How do you define dynamic routes in Flask?** ğŸ”¥

## â­ Beginner-Friendly Explanation

Dynamic routes allow URLs to accept **variables**, like:

* `/user/Tabish`
* `/product/15`

Syntax:

```python
@app.route('/user/<username>')
def user_profile(username):
    return f"Hello {username}"
```

Another example with integer:

```python
@app.route('/product/<int:id>')
def product(id):
    return f"Product ID is {id}"
```

### Why dynamic routes?

Because not every page is static.

Examples:

* View a specific user
* View specific blog post
* Open specific product page

---

## ğŸ•’ **30-sec Interview Answer**

Dynamic routes allow Flask to accept variables in URLs, like `/user/<name>` or `/product/<int:id>`, so you can handle user-specific or item-specific pages.

---

# âœ… **15. What HTTP methods does Flask support?** ğŸ”¥

## â­ Beginner-Friendly Explanation

HTTP methods are ways for browser/API clients to communicate.

Flask supports:

| Method      | Purpose               |
| ----------- | --------------------- |
| **GET**     | Retrieve data         |
| **POST**    | Send form/data        |
| **PUT**     | Update existing data  |
| **DELETE**  | Delete a resource     |
| **PATCH**   | Partial update        |
| **OPTIONS** | Check allowed methods |

Example:

```python
@app.route('/submit', methods=['POST'])
def submit():
    return "Submitted!"
```

---

### Why methods are needed?

Every web app needs to:

* GET data
* POST form
* UPDATE database
* DELETE items

These operations need HTTP methods.

---

## ğŸ•’ **30-sec Interview Answer**

Flask supports GET, POST, PUT, DELETE, PATCH, and OPTIONS. GET is for retrieving data while POST is for sending data; other methods handle updates and deletion.

---

# âœ… **16. How do you handle GET and POST in the same route?** ğŸ”¥

## â­ Beginner-Friendly Explanation

You can write one route that handles both GET + POST:

```python
from flask import request

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form['user']
        return f"Logged in as {username}"
    return "Login Page"
```

### How this works:

* **GET** â†’ Show login page
* **POST** â†’ Submit login form

### Why needed?

Because common pages like login/register use:

* GET â†’ show form
* POST â†’ process form

---

## ğŸ•’ **30-sec Interview Answer**

You define `methods=['GET', 'POST']` in the route and then check `request.method` inside the function to handle each method differently.

---

# âœ… **17. What does `url_for()` do in Flask?** ğŸ”¥

## â­ Beginner-Friendly Explanation

`url_for()` **generates URLs dynamically** using function names instead of hardcoding URLs.

Example:

```python
@app.route('/dashboard')
def dashboard():
    return "Dashboard"

@app.route('/go')
def go():
    return redirect(url_for('dashboard'))
```

Why use `url_for()`?

### Problems with hardcoding:

âŒ If route changes from `/dashboard` â†’ `/user-dashboard`
â†’ All pages break.

### `url_for()` advantages:

âœ” Safe
âœ” Auto-updates
âœ” Can generate URLs with parameters:

```python
url_for('profile', username='Tabish')
```

---

## ğŸ•’ **30-sec Interview Answer**

`url_for()` generates URLs dynamically using the function name. It prevents hardcoding URLs and automatically updates if routes change.

---

# âœ… **18. How do you implement redirects?** ğŸ”¥

## â­ Beginner-Friendly Explanation

Use Flaskâ€™s `redirect()` + `url_for()`.

Example:

```python
from flask import redirect, url_for

@app.route('/old')
def old():
    return redirect(url_for('new'))

@app.route('/new')
def new():
    return "This is new page"
```

### Why redirect?

* Move user from old page â†’ new page
* After login, redirect to dashboard
* After form submit, redirect to home

Redirects are essential for flow control.

---

## ğŸ•’ **30-sec Interview Answer**

You redirect using `redirect(url_for('function_name'))`. Itâ€™s used to move users from one route to another, like after login or form submission.

---

# âœ… **19. How do you get the client's IP address?**

## â­ Beginner-Friendly Explanation

You can access IP from the request object:

```python
from flask import request

@app.route('/ip')
def get_ip():
    return request.remote_addr
```

If behind a proxy (Nginx/Cloudflare):

```python
request.headers.get('X-Forwarded-For')
```

### Why needed?

* Logging
* Security
* Rate limiting
* Fraud detection

---

## ğŸ•’ **30-sec Interview Answer**

You get the client IP using `request.remote_addr` or `request.headers['X-Forwarded-For']` when using a proxy.

---

# âœ… **20. How does Flask internally match URL routes?**

## â­ Beginner-Friendly Explanation

Flask uses **Werkzeugâ€™s routing system**.

Internal process:

1. User hits URL
2. Flask compares URL with all defined routes
3. If match found â†’ execute that function
4. If no match â†’ return 404

Flask creates an internal mapping:

```
'/login' â†’ login()
'/register' â†’ register()
'/user/<id>' â†’ user()
```

### Pattern matching

Dynamic routes use variable converters:

* `<int:id>`
* `<string:name>`
* `<path:file_path>`

Werkzeug compiles route patterns and matches them efficiently.

---

## ğŸ•’ **30-sec Interview Answer**

Flask uses Werkzeugâ€™s routing engine. It compares the incoming URL with all defined route patterns, including dynamic variables, and executes the matching function. If none match, it returns 404.

---

---

# ğŸš€ **SECTION 3 â€” Templates (Jinja2)**

---

# âœ… **21. What are templates in Flask?** ğŸ”¥

## â­ Beginner-Friendly Explanation

Templates are **HTML files** that contain placeholders to show **dynamic data** from Python.

You store templates inside:

```
/templates/index.html
/templates/login.html
```

Example template:

```html
<h1>Hello {{ username }}</h1>
```

Python route:

```python
@app.route('/user')
def user():
    return render_template('index.html', username="Tabish")
```

ğŸ‘‰ The browser will see:
**Hello Tabish**

### Why templates are needed?

Because HTML pages should NOT contain backend logic.
Templates allow:

âœ” Clean separation of frontend & backend
âœ” Dynamic HTML content
âœ” Reusable components

### Where used?

* Login page
* Dashboard showing user data
* Email templates
* Forms & UI

---

## ğŸ•’ **30-sec Interview Answer**

Templates are HTML files that display dynamic data using placeholders. Flask uses templates to separate frontend UI from backend logic.

---

# âœ… **22. What is Jinja2 & why is it used?** ğŸ”¥

## â­ Beginner-Friendly Explanation

**Jinja2** is Flaskâ€™s **template engine**.

It allows:

* Variables: `{{ name }}`
* Loops: `{% for item in list %}`
* If conditions: `{% if %}`
* Template inheritance
* Filters (`|upper`, `|lower`)

Example:

```html
{% if user %}
  <p>Hello {{ user }}</p>
{% else %}
  <p>Please Login</p>
{% endif %}
```

### Why Jinja2?

Because normal HTML **cannot** run Python.
Jinja2 makes HTML dynamic.

### Where used?

* Displaying query results
* Displaying user profile data
* Showing conditional UI

---

## ğŸ•’ **30-sec Interview Answer**

Jinja2 is the template engine used by Flask to generate dynamic HTML. It supports variables, loops, conditions, and filters for rendering dynamic data.

---

# âœ… **23. How do you render templates using `render_template`?** ğŸ”¥

## â­ Beginner-Friendly Explanation

`render_template()` loads an HTML file from the **templates** folder and displays it.

Folder structure:

```
/app.py
/templates/home.html
```

Code:

```python
from flask import render_template

@app.route('/home')
def home():
    return render_template('home.html')
```

### Why needed?

Because browsers understand HTML, not Python functions.

---

## ğŸ•’ **30-sec Interview Answer**

`render_template()` loads and returns an HTML file from the templates folder so Flask can display frontend pages.

---

# âœ… **24. How do you pass variables/data to templates?** ğŸ”¥

## â­ Beginner-Friendly Explanation

You pass values as keyword arguments:

```python
@app.route('/profile')
def profile():
    return render_template("profile.html", name="Tabish", age=23)
```

Template:

```html
<h1>{{ name }}</h1>
<p>Age: {{ age }}</p>
```

You can pass:

âœ” Lists
âœ” Dictionaries
âœ” Database query results

### Why needed?

To show dynamic content on the page.

---

## ğŸ•’ **30-sec Interview Answer**

You pass variables using `render_template("file.html", key=value)` and access them in the template with `{{ key }}`.

---

# âœ… **25. What is template inheritance?**

## â­ Beginner-Friendly Explanation

Template inheritance reduces repeating HTML.

### Create a base template:

```html
<!-- base.html -->
<html>
<body>
  {% block content %}{% endblock %}
</body>
</html>
```

### Child template:

```html
{% extends 'base.html' %}

{% block content %}
<h2>Dashboard</h2>
{% endblock %}
```

### Why needed?

âœ” Avoid repeating header/footer
âœ” Cleaner code
âœ” Consistent UI across pages

---

## ğŸ•’ **30-sec Interview Answer**

Template inheritance lets you create a base layout and extend it in other templates, reducing repetition and keeping HTML organized.

---

# âœ… **26. What are Jinja2 filters?**

## â­ Beginner-Friendly Explanation

Filters modify values in templates.

Examples:

```html
{{ name | upper }}
{{ price | round(2) }}
{{ list | length }}
```

### Common filters:

* `upper`
* `lower`
* `title`
* `safe`
* `length`
* `replace`

### Why filters?

To format data before showing it.

---

## ğŸ•’ **30-sec Interview Answer**

Jinja2 filters modify variables inside templates, such as formatting text or numbers using syntax like `{{ value | filter }}`.

---

# ğŸ‰ **SECTION 3 DONE**

---

# ğŸš€ **SECTION 4 â€” Request, Response, Forms**

---

# âœ… **27. What is the Flask request object?** ğŸ”¥

## â­ Beginner-Friendly Explanation

The `request` object contains **everything sent by the client**:

âœ” Form data
âœ” JSON data
âœ” Query parameters
âœ” Cookies
âœ” Headers
âœ” Files

Example:

```python
from flask import request

@app.route('/submit', methods=['POST'])
def submit():
    username = request.form['username']
    return username
```

### Why needed?

Because the backend MUST read what the frontend/user sends.

---

## ğŸ•’ **30-sec Interview Answer**

The request object stores all incoming data like form inputs, JSON, headers, and files. It is used to read data sent by the client.

---

# âœ… **28. How do you handle form data (POST requests)?** ğŸ”¥

## â­ Beginner-Friendly Explanation

HTML Form:

```html
<form method="POST">
  <input name="username">
  <button>Submit</button>
</form>
```

Flask route:

```python
@app.route('/login', methods=['POST'])
def login():
    username = request.form['username']
    return username
```

### Other methods:

* `request.form` â†’ form fields
* `request.args` â†’ URL query parameters
* `request.json` â†’ JSON body
* `request.files` â†’ uploaded files

### Why needed?

User input is the core of any application:

âœ” Login
âœ” Registration
âœ” Search
âœ” Feedback form

---

## ğŸ•’ **30-sec Interview Answer**

Use `request.form` to read POST form data. Flask allows accessing submitted values using the field names.

---

# âœ… **29. How do you work with cookies in Flask?**

## â­ Beginner-Friendly Explanation

### Set cookie:

```python
resp = make_response("Cookie Set")
resp.set_cookie("username", "Tabish")
return resp
```

### Get cookie:

```python
username = request.cookies.get("username")
```

### Why cookies?

âœ” Session tracking
âœ” Remember user preferences
âœ” Auto login (with caution)

---

## ğŸ•’ **30-sec Interview Answer**

Use `response.set_cookie()` to store cookies and `request.cookies.get()` to read them. Cookies help store small client-side data.

---

# âœ… **30. What is `jsonify()` and why is it used?** ğŸ”¥

## â­ Beginner-Friendly Explanation

`jsonify()` converts Python data â†’ JSON response.

Example:

```python
from flask import jsonify

@app.route('/api')
def api():
    return jsonify({"status": "success", "code": 200})
```

### Why use `jsonify()`?

âœ” Automatically sets `Content-Type: application/json`
âœ” Safely converts dicts/lists
âœ” Used in REST APIs

---

## ğŸ•’ **30-sec Interview Answer**

`jsonify()` converts Python dictionaries to JSON and sets the correct content-type. It is used to return API responses.

---

# âœ… **31. How do you enable debug mode in Flask?** ğŸ”¥

## â­ Beginner-Friendly Explanation

Debug Mode:

âœ” Auto restarts server
âœ” Shows error page
âœ” Helps development

### Option 1 â€” In code:

```python
app.run(debug=True)
```

### Option 2 â€” Using environment variable:

```
export FLASK_DEBUG=1
flask run
```

---

## ğŸ•’ **30-sec Interview Answer**

Enable debug mode using `app.run(debug=True)` or `FLASK_DEBUG=1`. It restarts automatically and shows detailed error pages.

---

# âœ… **32. What is a thread-local object in Flask?**

## â­ Beginner-Friendly Explanation

Thread-local objects **store data separately for each request thread**.

Examples:

* `request`
* `session`
* `g`

These are isolated per request.

### Why needed?

Because multiple users may access your app at the same time.

Flask ensures:

âœ” User Aâ€™s request data â‰  User Bâ€™s request data
âœ” Thread-safe request handling

---

## ğŸ•’ **30-sec Interview Answer**

Thread-local objects store request-specific data separately for each request, ensuring different usersâ€™ data never mix. Examples: `request`, `session`, `g`.

---



---

# ğŸš€ **SECTION 5 â€” Sessions, Authentication & JWT**

---

# âœ… **33. How does Flask handle sessions?** ğŸ”¥

## â­ Beginner-Friendly Explanation

A **session** is a way to store small user-specific data on the server between requests.

Flask uses **signed cookies** for sessions.

Meaning:

âœ” Data stored in session is kept in the browser
âœ” But encrypted using `SECRET_KEY`
âœ” So users can't modify it

Example:

```python
from flask import session

session["username"] = "tabish"    # store session
print(session["username"])        # read session
session.clear()                   # delete session
```

### Why do we need sessions?

To remember who the user is:

* Login session
* Items in shopping cart
* User preferences

---

## ğŸ•’ **30-sec Interview Answer**

Flask stores session data in secure, signed cookies. It lets the app remember user-specific information like login status across requests.

---

# âœ… **34. What does the session object store?** ğŸ”¥

## â­ Beginner-Friendly Explanation

The `session` object stores **small, user-specific data**, such as:

* `user_id`
* `username`
* `role`
* login state
* theme (dark/light)
* preferences

Example:

```python
session["user_id"] = 12
```

### What you should NOT store?

âŒ Passwords
âŒ Large data
âŒ Sensitive info without encryption

---

## ğŸ•’ **30-sec Interview Answer**

Session stores small user-specific info like user_id, username, and login state. It should not store large or sensitive data.

---

# âœ… **35. What is the difference between `session` and `g`?** ğŸ”¥

## â­ Beginner-Friendly Explanation

| session                              | g                               |
| ------------------------------------ | ------------------------------- |
| Data stored in browser (client-side) | Stored only for current request |
| Persists across requests             | Deleted after request           |
| Used for login                       | Used for temporary variables    |
| Signed + secure cookie               | In-memory (not stored anywhere) |

Example use of `g`:

```python
from flask import g

g.db = connect_to_db()
```

Used for things that should exist **only during one request**.

---

## ğŸ•’ **30-sec Interview Answer**

`session` stores data across requests in secure cookies. `g` stores temporary request-level data. `session` persists, `g` resets every request.

---

# âœ… **36. What is Flask-Login and why is it used?** ğŸ”¥

## â­ Beginner-Friendly Explanation

**Flask-Login** simplifies user authentication.

It handles:

âœ” Login
âœ” Logout
âœ” Managing authenticated user
âœ” Protecting routes
âœ” Remember me

Without Flask-Login you would manually write everything.

### Example:

```python
from flask_login import LoginManager

login_manager = LoginManager(app)
```

---

## ğŸ•’ **30-sec Interview Answer**

Flask-Login is a library that handles login, logout, user sessions, and route protection. It simplifies authentication.

---

# âœ… **37. How do you implement login/logout using Flask-Login?** ğŸ”¥

## â­ Beginner-Friendly Explanation

### 1. Create User Model

```python
from flask_login import UserMixin

class User(UserMixin):
    pass
```

### 2. Initialize LoginManager

```python
login_manager = LoginManager(app)
```

### 3. Load user

```python
@login_manager.user_loader
def load_user(user_id):
    return User.get(user_id)
```

### 4. Login user

```python
from flask_login import login_user

login_user(user)
```

### 5. Protect routes

```python
from flask_login import login_required

@app.route('/dashboard')
@login_required
def dashboard():
    return "Welcome"
```

### 6. Logout

```python
from flask_login import logout_user

logout_user()
```

---

## ğŸ•’ **30-sec Interview Answer**

Use Flask-Login: `login_user()` to log in, `logout_user()` to log out, `login_required` to protect routes, and `user_loader` to load users.

---

# âœ… **38. How do you securely store passwords (bcrypt)?** ğŸ”¥

## â­ Beginner-Friendly Explanation

NEVER store plain passwords.
Use **bcrypt hashing**.

### Hash password:

```python
from flask_bcrypt import Bcrypt

bcrypt = Bcrypt(app)
hashed = bcrypt.generate_password_hash(password).decode()
```

### Verify password:

```python
bcrypt.check_password_hash(hashed, "user_input")
```

### Why bcrypt?

âœ” Slow & secure
âœ” Protects from brute-force attacks
âœ” Industry standard

---

## ğŸ•’ **30-sec Interview Answer**

Use bcrypt to hash passwords. `generate_password_hash()` to hash, `check_password_hash()` to verify. Never store raw passwords.

---

# âœ… **39. What is JWT and how is it implemented in Flask?** ğŸ”¥

## â­ Beginner-Friendly Explanation

JWT = JSON Web Token
Used for **API authentication**.

Contains:

* user_id
* expiry
* role

3 parts:

```
header.payload.signature
```

### Example in Flask:

Install:

```
pip install flask-jwt-extended
```

Create token:

```python
access_token = create_access_token(identity=user_id)
```

Verify token:

```python
@jwt_required()
def dashboard():
    return "Welcome"
```

---

## ğŸ•’ **30-sec Interview Answer**

JWT is a token-based authentication method for APIs. In Flask, we use `flask-jwt-extended` to create and verify tokens.

---

# âœ… **40. How do you secure API routes using JWT?** ğŸ”¥

## â­ Beginner-Friendly Explanation

Protect route:

```python
from flask_jwt_extended import jwt_required

@app.route('/profile')
@jwt_required()
def profile():
    return {"msg": "Secure Data"}
```

How it works:

âœ” Client sends token in headers
âœ” Backend verifies it
âœ” If valid â†’ allow
âœ” If invalid â†’ 401 Unauthorized

---

## ğŸ•’ **30-sec Interview Answer**

Use `@jwt_required()` on routes. The client sends JWT in headers, and Flask verifies it before allowing access.

---

# âœ… **41. What is Role-Based Access Control (RBAC)?**

## â­ Beginner-Friendly Explanation

RBAC controls which user can access which feature.

Example:

* Admin â†’ All routes
* User â†’ Limited
* Viewer â†’ Read-only

Implementation:

```python
if current_user.role != "admin":
    return "Forbidden", 403
```

---

## ğŸ•’ **30-sec Interview Answer**

RBAC assigns permissions based on roles like admin or user. Only allowed roles can access specific endpoints.

---

---

# ğŸš€ **SECTION 6 â€” CONTEXTS (Very Important)**

---

# âœ… **42. What is application context in Flask?** ğŸ”¥

## â­ Beginner-Friendly Explanation

Application context provides **app-level variables**.

It allows using:

* `current_app`
* `g`

Without passing the app everywhere.

This runs **outside request cycle**, like:

* CLI scripts
* Background tasks
* Database initialization

---

## ğŸ•’ **30-sec Interview Answer**

Application context stores app-level data and lets us use `current_app` and `g` without passing the app manually.

---

# âœ… **43. What is request context in Flask?** ğŸ”¥

## â­ Beginner-Friendly Explanation

Request context contains **data for the current HTTP request**:

* `request`
* `session`
* `url`
* `method`

Created when a request comes â†’ destroyed when it ends.

---

## ğŸ•’ **30-sec Interview Answer**

Request context stores request-specific data like headers, form data, and method. It exists only during a request.

---

# âœ… **44. Difference between app context & request context?** ğŸ”¥

## â­ Beginner-Friendly Table

| Feature   | App Context        | Request Context      |
| --------- | ------------------ | -------------------- |
| Scope     | Application        | One request          |
| Variables | `current_app`, `g` | `request`, `session` |
| Created   | App start          | Each request         |
| Lifetime  | Long               | Short                |

---

## ğŸ•’ **30-sec Interview Answer**

App context is for global application data, request context is for data of a single request like form, JSON, header.

---

# âœ… **45. How do you access the app context manually?**

## â­ Beginner-Friendly Explanation

```python
with app.app_context():
    print(current_app.name)
```

### Why needed?

* Running scripts
* Initializing database
* Cron jobs
* Tasks outside web requests

---

## ğŸ•’ **30-sec Interview Answer**

Use `with app.app_context():` to access app-level objects when no request is running.

---

# âœ… **46. What are context processors?**

## â­ Beginner-Friendly Explanation

Context processors automatically add data to **all templates**.

Example:

```python
@app.context_processor
def inject_user():
    return {"app_name": "ResumeDoctorAI"}
```

Now every template can access:

```html
{{ app_name }}
```

### Why needed?

âœ” Show global data
âœ” Navbar username
âœ” Project name

---

## ğŸ•’ **30-sec Interview Answer**

Context processors inject variables into all templates automatically. Useful for showing global values like app_name or logged-in user.

---

---

# ğŸš€ **SECTION 7 â€” DATABASE & ORM**

---

# âœ… **47. What is Flask-SQLAlchemy?** ğŸ”¥

## â­ Beginner-Friendly Explanation

`Flask-SQLAlchemy` is a Flask extension that makes it easy to interact with databases using **ORM (Object Relational Mapping)**.

ORM means:

âœ” You work with **Python classes** instead of SQL queries
âœ” Each class = Database table
âœ” Each object = Database row

Example:

```python
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy(app)
```

### Why do we need it?

* Easier than writing raw SQL
* Automatically creates tables
* Supports relationships
* Cleaner and safer code

### Where is it used?

* Login system (User table)
* Resume/JD storage
* Projects storing text, files, etc.

---

## ğŸ•’ 30-sec Interview Answer

Flask-SQLAlchemy is an ORM extension that lets us interact with databases using Python classes instead of raw SQL. It simplifies model creation, queries, and relationships.

---

# âœ… **48. How do you define models using Flask-SQLAlchemy?** ğŸ”¥

## â­ Beginner-Friendly Explanation

A **model** is a Python class that maps to a SQL table.

Example:

```python
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(100), unique=True)
    email = db.Column(db.String(150))
```

### Why?

âœ” Cleaner code
âœ” Auto table creation
âœ” Easy queries: `User.query.all()`

---

## ğŸ•’ 30-sec Interview Answer

A model is a Python class with attributes mapped to database columns using `db.Column`. SQLAlchemy creates and manages the table for us.

---

# âœ… **49. How does Flask handle database connections?** ğŸ”¥

## â­ Beginner-Friendly Explanation

Flask usually opens a **database connection per request**.

Process:

1. Request comes in
2. Flask opens DB connection
3. Executes queries
4. Closes connection after request ends

This is handled by:

* `before_request`
* `teardown_request`

If using Flask-SQLAlchemy, connection pooling is automatic.

---

## ğŸ•’ 30-sec Interview Answer

Flask opens one DB connection per request and closes it after the request ends. With SQLAlchemy, connection pooling and cleanup are automatic.

---

# âœ… **50. What is one-request-one-DB-connection pattern?** ğŸ”¥

## â­ Beginner-Friendly Explanation

This pattern means:

ğŸ‘‰ **Each HTTP request gets its own database connection**,
ğŸ‘‰ And that connection is closed when the request finishes.

Why is this needed?

âœ” Prevents connection leaks
âœ” Ensures thread safety
âœ” Makes sure data is consistent

Flask + SQLAlchemy handles this automatically.

---

## ğŸ•’ 30-sec Interview Answer

It means one database connection is created for each request and closed after the response. This avoids leaks and ensures thread safety.

---

# âœ… **51. What is Flask-Migrate?** ğŸ”¥

## â­ Beginner-Friendly Explanation

`Flask-Migrate` is a tool for **database migrations**.

Migration = updating database schema **without losing data**.

Example changes:

* Add new column
* Delete column
* Change data type

It uses **Alembic** under the hood.

---

## ğŸ•’ 30-sec Interview Answer

Flask-Migrate manages database schema changes using Alembic. It lets you add or modify tables without losing existing data.

---

# âœ… **52. How do you perform database migrations?** ğŸ”¥

## â­ Beginner-Friendly Explanation

### Step 1: Install

```
pip install flask-migrate
```

### Step 2: Initialize migrate

```python
from flask_migrate import Migrate

migrate = Migrate(app, db)
```

### Step 3: CLI commands

```
flask db init
flask db migrate -m "add user table"
flask db upgrade
```

### Why?

âœ” No need to drop database
âœ” Safe schema upgrade
âœ” Professional way to evolve DB

---

## ğŸ•’ 30-sec Interview Answer

Use `flask db migrate` to generate migration files and `flask db upgrade` to apply changes. Flask-Migrate uses Alembic to manage schema updates safely.

---

---

# ğŸš€ **SECTION 8 â€” REST APIs (8 Questions)**

---

# âœ… **53. What is REST and how is it implemented in Flask?** ğŸ”¥

## â­ Beginner-Friendly Explanation

REST = **Representational State Transfer**
A standard way to design **web APIs**.

Key ideas:

* Use URLs for resources
* Use HTTP methods (GET, POST, PUT, DELETE)
* Return JSON
* Stateless (no session stored on server)

Flask implementation example:

```python
@app.route('/users', methods=['GET'])
def get_users():
    return {"users": []}
```

---

## ğŸ•’ 30-sec Interview Answer

REST is an API style using HTTP methods and JSON responses. Flask implements REST using routes and methods like GET, POST, PUT, DELETE.

---

# âœ… **54. How do you create a REST API using Flask?** ğŸ”¥

## â­ Explanation + Code

```python
@app.route('/api/user', methods=['POST'])
def create_user():
    data = request.json
    return {"message": "User created", "data": data}, 201
```

Key steps:

âœ” Define route
âœ” Allow required HTTP method
âœ” Parse JSON
âœ” Return JSON response

---

## ğŸ•’ 30-sec Interview Answer

Define routes, accept JSON with `request.json`, process data, and return JSON using a status code.

---

# âœ… **55. How do you return JSON responses?** ğŸ”¥

## â­ Beginner-Friendly Explanation

Use `jsonify()`:

```python
from flask import jsonify

return jsonify({"status": "success"})
```

Or directly:

```python
return {"status": "success"}
```

Flask 2+ automatically sets JSON response headers.

---

## ğŸ•’ 30-sec Interview Answer

Use `jsonify()` or return a Python dictionary. Flask converts it to JSON with correct headers.

---

# âœ… **56. How do you handle different HTTP methods for an endpoint?** ğŸ”¥

## â­ Explanation + Code

```python
@app.route('/user', methods=['GET', 'POST'])
def user():
    if request.method == 'GET':
        return {"msg": "Fetching user"}
    if request.method == 'POST':
        return {"msg": "Creating user"}
```

---

## ğŸ•’ 30-sec Interview Answer

Add `methods=['GET','POST']` in the route and handle each method inside the function using `request.method`.

---

# âœ… **57. What is Flask-RESTful and how is it different from normal routes?** ğŸ”¥

## â­ Beginner-Friendly Explanation

Flask-RESTful is an extension for building APIs.

It provides:

âœ” Class-based Resources
âœ” Automatic method routing
âœ” Input validation
âœ” Cleaner structure

Example:

```python
from flask_restful import Resource, Api
api = Api(app)

class User(Resource):
    def get(self):
        return {"msg": "Hello"}

api.add_resource(User, '/user')
```

vs traditional:

```python
@app.route('/user')
def user():
    return {"msg": "Hello"}
```

---

## ğŸ•’ 30-sec Interview Answer

Flask-RESTful organizes APIs using class-based resources and automatic method mapping, making API code cleaner than normal Flask functions.

---

# âœ… **58. How do you secure APIs (Tokens, JWT, CORS)?** ğŸ”¥

## â­ Beginner-Friendly Explanation

### Methods:

1ï¸âƒ£ **JWT Token**

```python
@jwt_required()
```

2ï¸âƒ£ **API Keys**
Custom headers check.

3ï¸âƒ£ **CORS Protection**

```python
from flask_cors import CORS
CORS(app)
```

4ï¸âƒ£ Rate limiting
Using Flask-Limiter.

5ï¸âƒ£ Input validation
Using Marshmallow / manual checks.

---

## ğŸ•’ 30-sec Interview Answer

Secure APIs using JWT for authentication, CORS for cross-domain protection, HTTPS, validation, and rate limiting.

---

# âœ… **59. How do you validate request data in APIs?**

## â­ Beginner-Friendly Explanation

Validation ensures correct input before processing.

Ways:

### 1. Manual validation

```python
if "email" not in request.json:
    return {"error": "Email required"}, 400
```

### 2. Marshmallow schema

```python
from marshmallow import Schema, fields
```

### 3. WTForms

For form-based validation.

---

## ğŸ•’ 30-sec Interview Answer

Validate incoming JSON by checking required fields, data types, and constraintsâ€”either manually or using a schema library like Marshmallow.

---

# âœ… **60. How do you test APIs using Flaskâ€™s test client?** ğŸ”¥

## â­ Beginner-Friendly Explanation

Flask provides a built-in **test client**.

```python
def test_home():
    app.testing = True
    client = app.test_client()

    response = client.get('/api/home')
    assert response.status_code == 200
```

### Why?

âœ” No need to run server
âœ” Fast
âœ” Used in automated testing

---

## ğŸ•’ 30-sec Interview Answer

Use Flaskâ€™s `test_client()` to send requests (GET/POST) to routes without running the server and assert expected status codes or responses.

---

---

# âœ… **SECTION 9 â€” Middleware & Hooks (4 Questions)**

---

# **61. ğŸ”¥ What is middleware in Flask?**

## â­ Beginner-Friendly Explanation

Middleware is **code that runs before or after every request**, without modifying individual routes.

It helps with:

* Authentication checks
* Logging
* Opening DB connections
* Request validation
* Rate limiting
* Timing requests

Flask doesnâ€™t have a separate middleware layer like Django, but uses **hooks** instead (`before_request`, `after_request`).

---

## ğŸ–¥ Code Example

```python
@app.before_request
def check_auth():
    print("Running before every request")
```

---

## â“ Why Needed?

âœ” Avoid repeating the same logic in every route
âœ” Add security, monitoring, or cleanup

---

## ğŸ•’ 30-sec Interview Answer

Middleware in Flask is implemented using request hooks like `before_request` and `after_request`. It allows us to run code before or after every request for tasks like auth checks or logging.

---

---

# **62. ğŸ”¥ What is `before_request`?**

## â­ Beginner Explanation

`before_request` runs **before every request** is processed.

Use cases:

* Check user login session
* Validate API token
* Open database connection
* Block banned IPs

---

## ğŸ–¥ Code Example

```python
@app.before_request
def before_request_func():
    print("Before request logic...")
```

---

## ğŸ•’ 30-sec Interview Answer

`before_request` is a Flask hook that runs before each request. It's used for authentication checks, session validation, or setting up request-specific resources.

---

---

# **63. ğŸ”¥ What is `after_request`?**

## â­ Beginner Explanation

`after_request` runs **after the route returns a response**, but **before sending it to the client**.

Use cases:

* Modify response headers
* Add CORS headers
* Close DB connections
* Logging / analytics

---

## ğŸ–¥ Code Example

```python
@app.after_request
def add_headers(response):
    response.headers["X-App"] = "FlaskApp"
    return response
```

---

## ğŸ•’ 30-sec Interview Answer

`after_request` runs after the view function and is used to modify responses or clean up resources.

---

---

# **64. What is `teardown_request` and when is it used?**

## â­ Beginner Explanation

`teardown_request` executes **after the response is sent**, even if there was an exception.

Use cases:

* Close DB sessions
* Release resources
* Cleanup tasks

---

## ğŸ–¥ Code Example

```python
@app.teardown_request
def teardown_func(error=None):
    print("Cleaning up after request")
```

---

## ğŸ•’ 30-sec Interview Answer

`teardown_request` runs after the response has been sent, mainly used for cleanup like closing database connections, even if errors occurred.

---

---

# âœ… **SECTION 10 â€” Security (7 Questions)**

---

# **65. ğŸ”¥ What is CSRF and how is it prevented in Flask?**

## â­ Beginner Explanation

CSRF (Cross-Site Request Forgery) = User is tricked into performing actions they didnâ€™t intend (like form submission).

Flask prevents CSRF using:

* **Flask-WTF** â†’ Auto CSRF token
* Hidden field in forms
* `{{ form.hidden_tag() }}`

---

## ğŸ–¥ Code Example

```python
class LoginForm(FlaskForm):
    username = StringField()
    password = PasswordField()
    submit = SubmitField()
```

In template:

```html
<form method="POST">
    {{ form.hidden_tag() }}
</form>
```

---

## ğŸ•’ 30-sec Interview Answer

CSRF is prevented using unique CSRF tokens generated by Flask-WTF. Every POST form includes a hidden token that the server validates.

---

---

# **66. ğŸ”¥ What is XSS & how do you prevent it?**

## â­ Beginner Explanation

XSS (Cross-Site Scripting) = attacker injects malicious JavaScript into your website.

Prevention in Flask:

* Jinja2 auto-escapes HTML
* Never trust user input
* Use `|safe` carefully
* Validate and sanitize inputs

---

## ğŸ–¥ Example

```html
{{ user_input }}  <!-- auto escapes -->
```

---

## ğŸ•’ 30-sec Interview Answer

XSS is prevented because Jinja2 auto-escapes variables, meaning malicious scripts won't run unless explicitly allowed.

---

---

# **67. ğŸ”¥ How do you prevent SQL injection in Flask?**

## â­ Beginner Explanation

Use **parameterized queries** or **ORM (SQLAlchemy)**.

Never do this:

```python
cursor.execute("SELECT * FROM users WHERE username='" + username + "'")
```

Do this instead:

```python
cursor.execute("SELECT * FROM users WHERE username = %s", (username,))
```

Or with SQLAlchemy:

```python
User.query.filter_by(username=username).first()
```

---

## ğŸ•’ 30-sec Interview Answer

SQL injection is prevented using parameterized queries or ORM methods where SQLAlchemy escapes all inputs automatically.

---

---

# **68. ğŸ”¥ What are Flask security best practices?**

## â­ Beginner List

âœ” Use HTTPS
âœ” Use Flask-WTF for CSRF
âœ” Hash passwords with bcrypt
âœ” Avoid raw SQL
âœ” Validate input
âœ” Secure cookies with `httponly=True`
âœ” Protect API keys using environment variables
âœ” Enable CORS when needed

---

## ğŸ•’ 30-sec Interview Answer

Follow best practices like using HTTPS, CSRF tokens, password hashing, safe SQL queries, input validation, and secure cookies.

---

---

# **69. ğŸ”¥ How does Flask-WTF enable CSRF protection?**

## â­ Beginner Explanation

Flask-WTF:

âœ” Generates CSRF token
âœ” Adds hidden field in forms
âœ” Validates token on submit
âœ” Rejects request if token missing or invalid

---

## ğŸ–¥ Example

In form template:

```html
{{ form.hidden_tag() }}
```

---

## ğŸ•’ 30-sec Interview Answer

Flask-WTF automatically adds and validates CSRF tokens for all forms, protecting against CSRF attacks.

---

---

# **70. What is API rate limiting & how to implement it?**

## â­ Beginner Explanation

Rate limiting = limiting number of API calls per user/IP.

Why?

âœ” Protect server
âœ” Prevent abuse
âœ” Avoid DDoS

Use `Flask-Limiter`:

```python
from flask_limiter import Limiter

limiter = Limiter(app, key_func=get_remote_address)

@app.route('/api')
@limiter.limit("10/minute")
def api():
    return "OK"
```

---

## ğŸ•’ 30-sec Interview Answer

Rate limiting restricts API usage per user to prevent abuse. Flask-Limiter applies limits like "10 requests per minute".

---

---

# **71. How do you securely store API keys?**

## â­ Beginner Explanation

Never store keys in code.

Correct way:

* Use `.env` file
* Use environment variables
* Use secret managers (AWS, GCP)

Example:

```python
import os
API_KEY = os.getenv("API_KEY")
```

---

## ğŸ•’ 30-sec Interview Answer

Store keys using environment variables or .env files, never inside the codebase.

---

---

# âœ… **SECTION 11 â€” FILE UPLOADS (3 Questions)**

---

# **72. ğŸ”¥ How do you handle file uploads in Flask?**

## â­ Beginner Explanation

Steps:

1ï¸âƒ£ HTML form â†’ `multipart/form-data`
2ï¸âƒ£ Access file in backend via `request.files`
3ï¸âƒ£ Save file

---

## ğŸ–¥ Code Example

```python
@app.route('/upload', methods=['POST'])
def upload():
    file = request.files['resume']
    file.save("uploads/" + file.filename)
    return "Uploaded"
```

---

## ğŸ•’ 30-sec Interview Answer

Use `request.files` to get uploaded files and save them using `.save()` in a secure folder.

---

---

# **73. ğŸ”¥ How do you validate file extensions?**

## â­ Beginner Explanation

```python
ALLOWED = {'pdf', 'docx'}

def allowed(filename):
    return filename.split('.')[-1].lower() in ALLOWED
```

Use before saving:

```python
if not allowed(file.filename):
    return "Invalid file", 400
```

---

## ğŸ•’ 30-sec Interview Answer

Check the fileâ€™s extension against a whitelist (e.g., pdf, docx) before saving.

---

---

# **74. How do you handle large file uploads safely?**

## â­ Beginner Explanation

âœ” Set max file size
âœ” Stream upload instead of storing in memory
âœ” Validate format
âœ” Never trust filename

---

## ğŸ–¥ Limit size in config:

```python
app.config['MAX_CONTENT_LENGTH'] = 5 * 1024 * 1024  # 5MB
```

---

## ğŸ•’ 30-sec Interview Answer

Limit max upload size, validate file type, and use streaming or chunked uploads for very large files.

---

---

# âœ… **SECTION 12 â€” Deployment & Scaling (8 Questions)**

---

# **75. ğŸ”¥ How do you deploy a Flask app to production?**

## â­ Beginner-Friendly Explanation

Running `app.run()` is only for development.
For production, we need:

1ï¸âƒ£ **WSGI Server** â†’ Gunicorn / uWSGI
2ï¸âƒ£ **Reverse Proxy** â†’ Nginx
3ï¸âƒ£ **Environment Variables**
4ï¸âƒ£ **Virtual Environment**
5ï¸âƒ£ **Proper directory structure**

**Flow:**

Client â†’ Nginx â†’ Gunicorn â†’ Flask App

---

## ğŸ–¥ Example Commands

```bash
pip install gunicorn
gunicorn app:app --bind 0.0.0.0:8000
```

Nginx config sample:

```
proxy_pass http://127.0.0.1:8000;
```

---

## ğŸ•’ 30-sec Interview Answer

Flask is deployed using a production WSGI server like Gunicorn behind Nginx. Nginx handles static files and load balancing, while Gunicorn runs the Flask app.

---

---

# **76. ğŸ”¥ What is Gunicorn and why do we need it?**

## â­ Beginner Explanation

Gunicorn = **Production WSGI server** for Python apps.

Flaskâ€™s built-in server is:

âŒ Not secure
âŒ Cannot handle multiple users
âŒ Not optimized

Gunicorn provides:

âœ” Multi-worker concurrency
âœ” Better performance
âœ” Production-grade serving

---

## ğŸ–¥ Code Example

```bash
gunicorn app:app -w 4 -b 0.0.0.0:8000
```

---

## ğŸ•’ 30-sec Interview Answer

Gunicorn is a production WSGI server that runs Flask apps with multiple workers, providing better speed, concurrency, and reliability than the built-in development server.

---

---

# **77. ğŸ”¥ What is Nginx and why used with Gunicorn?**

## â­ Beginner Explanation

Gunicorn processes Python code, but itâ€™s not good at:

âŒ Serving static files
âŒ Handling many connections
âŒ SSL/HTTPS

Nginx is used because:

âœ” Handles high traffic
âœ” Acts as reverse proxy
âœ” Serves static files
âœ” Adds SSL support

---

## ğŸ•’ 30-sec Interview Answer

Nginx is used as a reverse proxy in front of Gunicorn to handle more traffic, serve static files efficiently, and provide security features like HTTPS.

---

---

# **78. ğŸ”¥ How do you deploy Flask on Docker?**

## â­ Beginner Explanation

With Docker:

âœ” App runs in isolated container
âœ” Same environment everywhere
âœ” Easy deployment

---

## ğŸ–¥ Dockerfile Example

```dockerfile
FROM python:3.10
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
CMD ["gunicorn", "app:app", "--bind", "0.0.0.0:8000"]
```

Build & Run:

```bash
docker build -t flaskapp .
docker run -p 8000:8000 flaskapp
```

---

## ğŸ•’ 30-sec Interview Answer

To deploy Flask in Docker, create a Dockerfile, install dependencies, copy your app, and run Gunicorn inside the container.

---

---

# **79. What is WSGI vs ASGI?**

## â­ Beginner Explanation

WSGI â€“ for **synchronous** Python apps (Flask, Django classic).
ASGI â€“ for **asynchronous** apps (FastAPI, Django async mode).

WSGI = 1 request â†’ 1 thread
ASGI = supports WebSockets + async I/O

---

## ğŸ•’ 30-sec Interview Answer

WSGI handles synchronous web apps like Flask, while ASGI supports asynchronous operations and WebSockets.

---

---

# **80. How do you deploy Flask on Heroku/Render?**

## â­ Beginner Explanation

Both platforms require:

âœ” `Procfile`
âœ” `requirements.txt`
âœ” Python runtime

**Heroku Procfile:**

```
web: gunicorn app:app
```

Render auto-detects Flask.

---

## ğŸ•’ 30-sec Interview Answer

Deployment on Heroku/Render requires a Procfile and Gunicorn. Push code, and the platform auto-builds and deploys the Flask app.

---

---

# **81. ğŸ”¥ How do you manage environment variables (.env)?**

## â­ Beginner Explanation

Never store secrets in code.

Use:

âœ” `.env` file (python-dotenv)
âœ” `os.getenv()`

---

## ğŸ–¥ Example

```python
from dotenv import load_dotenv
import os

load_dotenv()
API_KEY = os.getenv("API_KEY")
```

---

## ğŸ•’ 30-sec Interview Answer

Use a .env file and load variables with python-dotenv or system env vars to securely store secrets like keys and passwords.

---

---

# **82. ğŸ”¥ How do you scale a Flask app (workers, load balancing)?**

## â­ Beginner Explanation

âœ” Horizontal scaling â†’ More servers
âœ” Vertical scaling â†’ More CPU/RAM
âœ” Use Gunicorn workers
âœ” Nginx load balancing
âœ” Database connection pooling

---

## ğŸ•’ 30-sec Interview Answer

Scale Flask using multiple Gunicorn workers and load balancing with Nginx. For bigger systems, run multiple containers behind a load balancer.

---

---

# âœ… **SECTION 13 â€” Logging, Error Handling, Testing (6 Questions)**

---

# **83. ğŸ”¥ How do you handle errors using `@app.errorhandler`?**

## â­ Beginner Explanation

Use decorators to handle errors globally:

---

## ğŸ–¥ Code Example

```python
@app.errorhandler(404)
def not_found(e):
    return "Page not found", 404
```

---

## ğŸ•’ 30-sec Interview Answer

`@app.errorhandler` catches errors like 404 or 500 and returns custom responses.

---

---

# **84. ğŸ”¥ How do you design custom JSON error responses?**

## â­ Beginner Explanation

Return JSON instead of HTML:

```python
@app.errorhandler(404)
def not_found(e):
    return jsonify({"error": "Not Found"}), 404
```

---

## ğŸ•’ 30-sec Interview Answer

Create error handlers and return a JSON dictionary along with the correct status code.

---

---

# **85. What is `abort()` used for?**

## â­ Beginner Explanation

Abort stops the request and returns an HTTP error:

```python
from flask import abort
abort(400)
```

---

## ğŸ•’ 30-sec Interview Answer

`abort()` immediately stops execution and returns an error like 400 or 403.

---

---

# **86. What is logging in Flask?**

## â­ Beginner Explanation

Logging helps track:

âœ” Errors
âœ” Debug info
âœ” User actions

---

## ğŸ–¥ Example

```python
import logging
logging.basicConfig(level=logging.INFO)
logging.info("App started")
```

---

## ğŸ•’ 30-sec Interview Answer

Logging records server activity to debug issues and monitor behavior.

---

---

# **87. ğŸ”¥ How do you test routes using `test_client()`?**

## â­ Beginner Explanation

Flask provides a built-in fake client for testing routes.

---

## ğŸ–¥ Code Example

```python
with app.test_client() as client:
    response = client.get('/login')
    assert response.status_code == 200
```

---

## ğŸ•’ 30-sec Interview Answer

Use Flaskâ€™s `test_client()` to simulate requests and assert status codes or responses.

---

---

# **88. How do you handle 400/401/403/404 errors?**

## â­ Beginner Explanation

Use custom handlers:

```python
@app.errorhandler(400)
def bad_req(e): return jsonify(error="Bad Request"), 400
```

---

## ğŸ•’ 30-sec Interview Answer

Define custom error handlers for each status code using `@app.errorhandler`.

---

---

# âœ… **SECTION 14 â€” Advanced Flask (4 Questions)**

---

# **89. What are Flask signals?**

## â­ Beginner Explanation

Signals notify parts of app when events occur.

Example:

* user_logged_in
* template_rendered
* request_started

Provided by **blinker** library.

---

## ğŸ•’ 30-sec Interview Answer

Signals allow different parts of a Flask app to communicate when certain events occur.

---

---

# **90. ğŸ”¥ What is request dispatching?**

## â­ Beginner Explanation

Flask request dispatching process:

1ï¸âƒ£ Match URL â†’ find route
2ï¸âƒ£ Create request context
3ï¸âƒ£ Run `before_request` hooks
4ï¸âƒ£ Call view function
5ï¸âƒ£ Build response
6ï¸âƒ£ Run `after_request`
7ï¸âƒ£ Send to client

---

## ğŸ•’ 30-sec Interview Answer

Request dispatching is the internal process where Flask matches a URL to a route, runs hooks, calls the view, builds the response, and sends it back.

---

---

# **91. How do you make Flask asynchronous?**

## â­ Beginner Explanation

Flask is sync, but async can be added via:

âœ” Using `async def` in Flask 2.x
âœ” Using Celery for background tasks
âœ” Using Flask-SocketIO

---

## ğŸ–¥ Example

```python
@app.get("/data")
async def get_data():
    return {"msg": "async supported"}
```

---

## ğŸ•’ 30-sec Interview Answer

Flask now supports `async def` routes, but for heavy background jobs we use Celery.

---

---

# **92. ğŸ”¥ How do you implement WebSockets using Flask-SocketIO?**

## â­ Beginner Explanation

Flask cannot handle WebSockets natively â†’ use Flask-SocketIO.

---

## ğŸ–¥ Code Example

```python
from flask_socketio import SocketIO, send
socketio = SocketIO(app)

@socketio.on('message')
def handle_msg(msg):
    send("Received: " + msg)
```

Run:

```bash
socketio.run(app)
```

---

## ğŸ•’ 30-sec Interview Answer

Use Flask-SocketIO. It wraps WebSocket communication and allows real-time messaging with simple event handlers.

---

---







